import argparse
import datetime
from pathlib import Path

HEADERS = "headers"
TYPES = "types"
REQUIRED = "required"

# Note that headers in the definitions are *after* removal of spaces
DEFINITIONS = {
    "results": {
        HEADERS: ["#", "Halfmove", "Player", "SAN", "Annotation", "Move", "Previous", "Score", "Evaluation", "CPL", "Win%", "Accuracy%"],
        TYPES: [int, int, str, str, str, str, int, int, str, int, float, float],
        REQUIRED: [True, True, True, True, False, True, True, True, False, True, True, True]
    },
    "summary": {
        HEADERS: ["Player", "ACPL", "Accuracy%", "?!", "?", "??"],
        TYPES: [str, float, float, int, int, int],
        REQUIRED: [True, True, True, True, True, True]
    },
    "winchance": {
        HEADERS: ["#", "WinChance"],
        TYPES: [int, float],
        REQUIRED: [True, True]
    },
    "info": {
        HEADERS: ["Item", "Value"],
        TYPES: [str, str],
        REQUIRED: [True, False]
    }
}

# Get the script details to use as versioning information
path = Path(__file__)
modification_timestamp = path.stat().st_mtime
modification_date = datetime.datetime.fromtimestamp(modification_timestamp)

# Set up the command line parser
parser = argparse.ArgumentParser(
    prog=f"{path.stem} {modification_date.strftime("%Y-%m-%d %H:%M:%S")}",
    description="Integration Test Text Table Verifier"
)

parser.add_argument("-f", "--file", nargs=1, help="Path to the file to verify", required=True)
parser.add_argument("-t", "--type", nargs=1, help="Type of table data expected in the file", required=True)

#Â Parse the command line and make sure both arguments are specified
args = parser.parse_args()

# Load the file
print(f"\nVerifying file content for {args.file[0]} of type {args.type[0]}")
with open(args.file[0]) as text_file:
    content = text_file.readlines()

# Extract the table data and split into column values. Note the [1:-1] that removes the blank
# cell generated by | at the start and end of each properly formatted table row
table = [l.replace(" ", "").replace("\n", "").split("|")[1:-1] for l in content if l.startswith("|")]

# All tables should have at least two lines at this point, given the separator's been removed
# The first are the headers and the second is at least one row of data
length = len(table)
if length < 2:
    message = f"Table has {length} row{'s' if length != 1 else ''} of data - expected a minimum of 2"
    raise ValueError(message)

# Get the definitions for this file type and make sure they're consistent
definitions = DEFINITIONS[args.type[0]]
headers_length = len(definitions[HEADERS])
types_length = len(definitions[TYPES])
required_length = len(definitions[REQUIRED])

assert headers_length == types_length
assert headers_length == required_length

# Confirm the headers are correct
assert table[0] == definitions[HEADERS]

# Perform row-level validation
for i, row in enumerate(table[1:]):
    for j, col in enumerate(row):
        # Confirm required values are present
        if not col and definitions[REQUIRED][j]:
            message = f"Value for mandatory column '{definitions[HEADERS][j]}' missing at row {i + 1}"
            raise ValueError(message)

        # Confirm the type is correct
        try:
            _ = definitions[TYPES][j](col)
        except:
            message = f"Invalid value '{col}' for '{definitions[HEADERS][j]}' at row {i + 1}"
            raise ValueError(message)
